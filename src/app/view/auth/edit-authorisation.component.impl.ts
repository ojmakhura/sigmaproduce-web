// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { HttpClient } from '@angular/common/http';
import { Component, Injector } from '@angular/core';
import { EditAuthorisationSaveForm, EditAuthorisationVarsForm } from '@app/view/auth/edit-authorisation.component';
import { EditAuthorisationComponent, EditAuthorisationDeleteForm } from '@app/view/auth/edit-authorisation.component';
import { SelectItem } from '@app/utils/select-item';
import { environment } from '@env/environment';
import * as AuthorisationActions from '@app/store/auth/authorisation.actions';
import * as AccessPointSelectors from '@app/store/access/access-point.selectors';
import * as AccessPointActions from '@app/store/access/access-point.actions';

import { select } from '@ngrx/store';
import { AccessPointCriteria } from '@app/model//access/access-point-criteria';
import { AccessPointVO } from '@app/model//access/access-point-vo';
import * as ViewActions from '@app/store/view/view.actions';
import * as ViewSelectors from '@app/store/view/view.selectors';
import { Observable } from 'rxjs';
import { FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { SharedModule } from '@app/@shared';
import { MaterialModule } from '@app/material.module';
import { CsvModule } from '@ctrl/ngx-csv';
@Component({
  selector: 'app-edit-authorisation',
  templateUrl: './edit-authorisation.component.html',
  styleUrls: ['./edit-authorisation.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    TranslateModule,
    SharedModule,
    MaterialModule,
    CsvModule,
  ],
})
export class EditAuthorisationImplComponent extends EditAuthorisationComponent {
  protected http: HttpClient;
  unauthorisedUrls$: Observable<string[]>;
  deleteUnrestricted: boolean = true;

  constructor(private injector: Injector) {
    super(injector);
    this.http = this._injector.get(HttpClient);
    // this.keycloakService = this._injector.get(KeycloakService);
    this.authorisationAccessPoints$ = this.store.pipe(select(AccessPointSelectors.selectAccessPoints));
    this.unauthorisedUrls$ = this.store.pipe(select(ViewSelectors.selectUnauthorisedUrls));
  }

  override doNgOnDestroy(): void {}

  override beforeOnInit(form: EditAuthorisationVarsForm): EditAuthorisationVarsForm {
    // this.keycloakService.loadUserProfile().then((profile) => {
    //   if (!profile) return;

    //   this.http.get<any[]>(`${environment.keycloakRealmUrl}/clients`).subscribe((clients) => {
    //     let client = clients.filter((client) => client.clientId === environment.keycloak.clientId)[0];

    //     if (client) {
    //       this.http
    //         .get<any[]>(
    //           `${environment.keycloakRealmUrl}/users/${profile.id}/role-mappings/clients/${client.id}/composite`
    //         )
    //         .subscribe((roles) => {
    //           roles
    //             .sort((a, b) => a.name.localeCompare(b.name))
    //             .forEach((role) => {
    //               if (this.keycloakService.getUserRoles().includes(role.name)) {
    //                 let item = new SelectItem();
    //                 item.label = role['description'];
    //                 item.value = role['name'];

    //                 this.authorisationRolesBackingList.push(item);
    //               }
    //             });
    //         });
    //     }
    //   });

    //   this.http
    //     .get<any[]>(`${environment.keycloakRealmUrl}/users/${profile.id}/role-mappings/realm/composite`)
    //     .subscribe((roles) => {
    //       roles
    //         .sort((a, b) => a.name.localeCompare(b.name))
    //         .forEach((role: any) => {
    //           if (this.keycloakService.getUserRoles().includes(role.name) && !role.description?.includes('${')) {
    //             let item = new SelectItem();
    //             item.label = role['description'];
    //             item.value = role['name'];

    //             this.authorisationRolesBackingList.push(item);
    //           }
    //         });
    //     });
    // });

    return form;
  }

  override handleFormChanges(change: any): void {}

  override afterOnInit() {}

  override createAccessPointVOGroup(value: AccessPointVO): FormGroup {
    return this.formBuilder.group({
      id: [value?.id],
      createdBy: [value?.createdBy],
      updatedBy: [value?.updatedBy],
      createdDate: [value?.createdDate],
      updatedDate: [value?.updatedDate],
      name: [value?.name],
      url: [value?.url],
      accessPointType: this.formBuilder.group({
        id: [value?.accessPointType?.id],
        code: [value?.accessPointType?.code],
        name: [value?.accessPointType?.name],
      }),
    });
  }

  override doNgAfterViewInit(): void {
    // this.store.dispatch(
    //   ViewActions.loadViewAuthorisations({
    //     viewUrl: '/auth/edit-authorisation',
    //     roles: this.keycloakService.getUserRoles(),
    //     loading: true,
    //   })
    // );

    this.route.queryParams.subscribe((queryParams: any) => {
      if (queryParams?.id) {
        this.store.dispatch(
          AuthorisationActions.findById({
            id: queryParams?.id,
            loading: false,
            loaderMessage: 'Loading authorisations by id ...',
          })
        );
      }
    });

    // this.store.dispatch(
    //   ViewActions.loadViewAuthorisations({
    //     viewUrl: '/authorisation/edit-authorisation',
    //     roles: this.keycloakService.getUserRoles(),
    //     loading: true,
    //   })
    // );

    this.unauthorisedUrls$.subscribe((restrictedItems) => {
      restrictedItems.forEach((item) => {
        if (item === '/authorisation/edit-authorisation/{button:delete}') {
          this.deleteUnrestricted = false;
        }
      });
    });

    this.authorisation$.subscribe((authorisation) => {
      this.setEditAuthorisationFormValue({ authorisation: authorisation });
    });

    this.unauthorisedUrls$.subscribe((restrictedItems) => {
      restrictedItems.forEach((item) => {
        if (item === '/auth/edit-authorisation/{button:delete}') {
          this.deleteUnrestricted = false;
        }
      });
    });
  }

  /**
   * This method may be overwritten
   */
  override beforeEditAuthorisationSave(form: EditAuthorisationSaveForm): void {
    if (this.editAuthorisationForm.valid) {
      // if (form.authorisation?.id) {
      //   form.authorisation.updatedBy = this.keycloakService.getUsername();
      //   form.authorisation.updatedDate = new Date();
      // } else {
      //   form.authorisation.createdBy = this.keycloakService.getUsername();
      //   form.authorisation.createdDate = new Date();
      // }

      this.store.dispatch(
        AuthorisationActions.save({
          authorisation: form.authorisation,
          loading: true,
          loaderMessage: 'Saving authorisation ...',
        })
      );
    } else {
      let messages: string[] = [];
      if (!this.authorisationControl.valid) {
        messages.push('Authorisation has errors, Please fill in the required form fields.');
      }
      if (!this.authorisationAccessPointControl.valid) {
        messages.push('Access Point is missing, click the addbox to add one');
      }
      this.store.dispatch(AuthorisationActions.authorisationFailure({ messages: messages }));
    }
  }

  override beforeEditAuthorisationDelete(form: EditAuthorisationDeleteForm): void {
    if (form?.authorisation?.id && confirm('Are you sure you want to delete the authorisation?')) {
      this.store.dispatch(
        AuthorisationActions.remove({
          id: form?.authorisation?.id,
          loading: false,
          loaderMessage: 'Removing authorisation ...',
        })
      );
      this.editAuthorisationFormReset();
    } else {
      this.store.dispatch(
        AuthorisationActions.authorisationFailure({ messages: ['Please select something to delete'] })
      );
    }
  }

  override authorisationAccessPointSearch(): void {
    let criteria: AccessPointCriteria = new AccessPointCriteria();
    criteria.name = this.authorisationAccessPointSearchField.value;
    criteria.url = this.authorisationAccessPointSearchField.value;
    this.store.dispatch(
      AccessPointActions.search({ criteria: criteria, loading: true, loaderMessage: 'Searching access points' })
    );
  }

  override editAuthorisationFormReset() {
    this.store.dispatch(AuthorisationActions.authorisationReset());
    this.editAuthorisationForm.reset();
    this.editAuthorisationForm.markAsPristine();
    this.authorisationRolesControl.clear();

    if (this.router.url.substring(0, this.router.url.indexOf('?'))) {
      this.router.navigate([this.router.url.substring(0, this.router.url.indexOf('?'))]);
    } else {
      this.router.navigate([this.router.url]);
    }
  }
}
